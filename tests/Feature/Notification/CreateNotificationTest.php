<?php

use App\Notification;
use Illuminate\Http\Response;
use Laravel\Lumen\Testing\DatabaseMigrations;

use App\Http\Resources\NotificationResource;
use Illuminate\Validation\ValidationException;

class CreateNotificationTest extends TestCase
{
    use DatabaseMigrations;

    private $preferences;

    public function setUp() {
        parent::setUp(); // TODO: Change the autogenerated stub

        $preferencesNone = $this->makeFakeNotificationPreferences(0);
        $preferencesAll = $this->makeFakeNotificationPreferences(1);

        $preferencesNone->user()->associate($this->otherUser);
        $preferencesNone->save();

        $preferencesAll->user()->associate($this->user);
        $preferencesAll->save();
    }

    public function testMigrationAll() {
        $this->assertEquals(true, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_AUDIT_RELEASE_REQUIRED, $this->user->id));
        $this->assertEquals(true, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_AUDIT_OVERDUE, $this->user->id));
        $this->assertEquals(true, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_AUDIT_COMPLETED, $this->user->id));
        $this->assertEquals(true, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_AUDIT_ASSIGNED, $this->user->id));
        $this->assertEquals(true, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_TASK_ASSIGNED, $this->user->id));
        $this->assertEquals(true, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_TASK_UPDATED, $this->user->id));
        $this->assertEquals(true, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_TASK_COMPLETED, $this->user->id));
        $this->assertEquals(true, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_TASK_DELETED, $this->user->id));

        $this->assertEquals(false, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_AUDIT_RELEASE_REQUIRED, $this->otherUser->id));
        $this->assertEquals(false, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_AUDIT_OVERDUE, $this->otherUser->id));
        $this->assertEquals(false, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_AUDIT_COMPLETED, $this->otherUser->id));
        $this->assertEquals(false, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_AUDIT_ASSIGNED, $this->otherUser->id));
        $this->assertEquals(false, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_TASK_ASSIGNED, $this->otherUser->id));
        $this->assertEquals(false, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_TASK_UPDATED, $this->otherUser->id));
        $this->assertEquals(false, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_TASK_COMPLETED, $this->otherUser->id));
        $this->assertEquals(false, Notification::doesUserWantToReceiveNotification(Notification::PERMISSION_NAME_TASK_DELETED, $this->otherUser->id));
    }

    public function provideInvalidAccessData()
    {
        return [
            [null, Response::HTTP_UNAUTHORIZED],
            [self::$USER, Response::HTTP_UNAUTHORIZED]
        ];
    }

    /**
     * @param $userKey
     * @param $statusCode
     * @group notifications
     * @dataProvider provideInvalidAccessData
     */
    public function testInvalidAccess($userKey, $statusCode)
    {
        $this->json('POST', '/notifications');
        $this->seeStatusCode($statusCode);
        $this->seeHeader('Content-Type', 'application/json');
    }

    public function provideValidAccessData()
    {
        return [
            [self::$USER],
            [self::$OTHER_ADMIN],
            [self::$SUPER_ADMIN]
        ];
    }

    /**
     * @param $userKey
     * @group notifications
     * @dataProvider provideValidAccessData
     */
    public function testValidAccess($userKey)
    {
        $user = $this->getUser($userKey);
        $this->actingAs($user);

        /**
         * Create a notification with random data
         */
        $notification = factory(Notification::class)->make();

        /**
         * Post json request
         */
        $this->json('POST', '/notifications', [
            'user_id' => $notification->user_id,
            'sender_id' => $notification->sender_id,
            'link' => $notification->link,
            'title' => $notification->title,
            'message' => $notification->message,
            'read' => $notification->read,
            'pushed' => $notification->pushed,
            'createdAt' => $notification->createdAt,
            'readAt' => $notification->readAt,
            'updatedAt' => $notification->updatedAt
        ]);

        /**
         * What do we expect?
         */
        $this->seeHeader('Content-Type', 'application/json');
        $this->seeStatusCode(Response::HTTP_CREATED);
    }

    /**
     * Returns test data for invalid entitites
     *
     * @return array
     */
    public function provideInvalidEntities()
    {
        $tooLongString = str_repeat('123', 123);
        $invalidNumberString = 'abc';
        $invalidDateString = '2020202020';

        return [
            ['user_id', null],
            ['user_id', 1],
            ['user_id', $tooLongString],
            ['sender_id', null],
            ['sender_id', 1],
            ['sender_id', $tooLongString],
            ['link', null],
            ['link', $tooLongString],
            ['title', null],
            ['title', $tooLongString],
            ['read', null],
            ['read', $invalidNumberString],
            ['pushed', null],
            ['pushed', $invalidNumberString],
            ['readAt', null],
            ['readAt', $invalidDateString],
        ];
    }

    /**
     * Test creating a notification with invalid data
     *
     * @param $attributeKey
     * @param $attributeValue
     * @group notifications
     * @dataProvider provideInvalidEntities
     */
    public function testInvalidEntities($attributeKey, $attributeValue)
    {
        $this->actingAs($this->user);

        $notificationToAdd = factory(Notification::class)->make();

        $dataToSet = array_merge([
            'user_id' => $notificationToAdd->user_id,
            'sender_id' => $notificationToAdd->sender_id,
            'link' => $notificationToAdd->link,
            'title' => $notificationToAdd->title,
            'message' => $notificationToAdd->message,
            'read' => $notificationToAdd->read,
            'pushed' => $notificationToAdd->pushed,
            'createdAt' => $notificationToAdd->createdAt,
            'readAt' => $notificationToAdd->readAt,
            'updatedAt' => $notificationToAdd->updatedAt
        ], [$attributeKey => $attributeValue]);

        $this->json('POST', '/notifications', $dataToSet);
        $this->seeHeader('Content-Type', 'application/json');
        $this->seeStatusCode(Response::HTTP_UNPROCESSABLE_ENTITY);
    }

}

?>